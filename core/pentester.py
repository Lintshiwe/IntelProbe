"""
Automated Penetration Testing Module for IntelProbe
Provides AI-driven penetration testing and exploitation capabilities
"""

import logging
import time
import json
from dataclasses import dataclass
from typing import Dict, List, Any, Optional, Union
from pathlib import Path
import threading
from datetime import datetime
import asyncio
from concurrent.futures import ThreadPoolExecutor
import socket
import subprocess
import platform
import re

@dataclass
class ExploitTemplate:
    """Template for exploitation attempts"""
    name: str
    description: str
    target_service: str
    requirements: List[str]
    success_indicators: List[str]
    payload: str
    cleanup: str
    safety_checks: List[str]

@dataclass
class PenetrationTest:
    """Container for penetration test results"""
    test_id: str
    timestamp: str
    target: str
    successful_exploits: List[Dict[str, Any]]
    failed_exploits: List[Dict[str, Any]]
    vulnerabilities: List[Dict[str, Any]]
    evidence: List[Dict[str, Any]]
    notes: List[str]
    risk_level: str
    recommendations: List[str]

class PenTester:
    """Automated penetration testing engine"""

    def __init__(self, config, ai_engine):
        """Initialize pentesting engine"""
        self.config = config
        self.ai_engine = ai_engine
        self.logger = logging.getLogger(__name__)
        
        # State tracking
        self.active_test = False
        self.current_target = None
        self.successful_exploits = []
        self.failed_exploits = []
        self.discovered_vulns = []
        
        # Threading setup
        self.thread_pool = ThreadPoolExecutor(max_workers=10)
        self.stop_event = threading.Event()
        
        # Load exploit database
        self._load_exploit_database()
        self._load_vulnerability_database()

    def start_pentest(self, target: str, options: Dict[str, Any] = None) -> str:
        """
        Start a new penetration test
        
        Args:
            target: Target system/network
            options: Test configuration options
            
        Returns:
            test_id: Unique identifier for the test
        """
        try:
            test_id = f"pentest_{int(time.time())}"
            self.logger.info(f"🎯 Starting penetration test: {test_id}")
            
            # Initialize test state
            self.active_test = True
            self.current_target = target
            self.successful_exploits = []
            self.failed_exploits = []
            self.discovered_vulns = []
            
            # Configure test options
            self.test_options = options or {}
            
            # Start testing threads
            self._start_vulnerability_discovery()
            self._start_exploit_attempts()
            self._start_persistence_checking()
            
            return test_id
            
        except Exception as e:
            self.logger.error(f"❌ Failed to start pentest: {e}")
            raise

    def _start_vulnerability_discovery(self) -> None:
        """Start vulnerability discovery process"""
        def discoverer():
            try:
                while not self.stop_event.is_set():
                    # Port scanning
                    open_ports = self._scan_ports(self.current_target)
                    
                    # Service enumeration
                    services = self._enumerate_services(open_ports)
                    
                    # Vulnerability checking
                    self._check_vulnerabilities(services)
                    
                    time.sleep(60)  # Scan every minute
                    
            except Exception as e:
                self.logger.error(f"Vulnerability discovery error: {e}")
        
        thread = threading.Thread(target=discoverer, daemon=True)
        thread.start()

    def _start_exploit_attempts(self) -> None:
        """Start automated exploitation attempts"""
        def exploiter():
            try:
                while not self.stop_event.is_set():
                    # Get vulnerabilities to exploit
                    vulns_to_exploit = [v for v in self.discovered_vulns if not v.get('exploited')]
                    
                    for vuln in vulns_to_exploit:
                        # Find matching exploits
                        exploits = self._find_matching_exploits(vuln)
                        
                        for exploit in exploits:
                            # Verify exploit safety
                            if self._verify_exploit_safety(exploit):
                                # Attempt exploitation
                                result = self._attempt_exploit(exploit, vuln)
                                
                                if result['success']:
                                    self.successful_exploits.append(result)
                                    vuln['exploited'] = True
                                else:
                                    self.failed_exploits.append(result)
                    
                    time.sleep(300)  # Check every 5 minutes
                    
            except Exception as e:
                self.logger.error(f"Exploitation error: {e}")
        
        thread = threading.Thread(target=exploiter, daemon=True)
        thread.start()

    def _start_persistence_checking(self) -> None:
        """Start checking for persistence mechanisms"""
        def checker():
            try:
                while not self.stop_event.is_set():
                    # Check successful exploits
                    for exploit in self.successful_exploits:
                        if not exploit.get('checked_persistence'):
                            # Look for persistence indicators
                            persistence = self._check_persistence(exploit)
                            
                            if persistence:
                                exploit['persistence'] = persistence
                                self.logger.warning(f"⚠️ Persistence mechanism found: {persistence['type']}")
                            
                            exploit['checked_persistence'] = True
                    
                    time.sleep(600)  # Check every 10 minutes
                    
            except Exception as e:
                self.logger.error(f"Persistence checking error: {e}")
        
        thread = threading.Thread(target=checker, daemon=True)
        thread.start()

    def _scan_ports(self, target: str) -> List[Dict[str, Any]]:
        """Perform port scanning"""
        open_ports = []
        
        try:
            # Basic TCP port scan
            common_ports = [21, 22, 23, 25, 53, 80, 443, 445, 3306, 3389, 5432, 8080]
            
            for port in common_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                
                if sock.connect_ex((target, port)) == 0:
                    # Port is open
                    open_ports.append({
                        'port': port,
                        'state': 'open',
                        'service': self._identify_service(target, port)
                    })
                
                sock.close()
                
        except Exception as e:
            self.logger.debug(f"Port scanning error: {e}")
            
        return open_ports

    def _enumerate_services(self, ports: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Enumerate services on open ports"""
        services = []
        
        try:
            for port_info in ports:
                service = {
                    'port': port_info['port'],
                    'name': port_info['service'].get('name', 'unknown'),
                    'version': port_info['service'].get('version', 'unknown'),
                    'banner': port_info['service'].get('banner', '')
                }
                
                # Additional service detection
                if service['name'] == 'unknown':
                    # Try banner grabbing
                    banner = self._grab_banner(self.current_target, port_info['port'])
                    if banner:
                        service['banner'] = banner
                        service.update(self._parse_banner(banner))
                
                services.append(service)
                
        except Exception as e:
            self.logger.debug(f"Service enumeration error: {e}")
            
        return services

    def _check_vulnerabilities(self, services: List[Dict[str, Any]]) -> None:
        """Check services for known vulnerabilities"""
        try:
            for service in services:
                # Check version against vulnerability database
                vulns = self._check_version_vulnerabilities(
                    service['name'],
                    service['version']
                )
                
                # Check for common misconfigurations
                misconfigs = self._check_misconfigurations(service)
                
                # Add discovered vulnerabilities
                for vuln in vulns + misconfigs:
                    if vuln not in self.discovered_vulns:
                        vuln['service'] = service
                        vuln['timestamp'] = datetime.now().isoformat()
                        self.discovered_vulns.append(vuln)
                
        except Exception as e:
            self.logger.debug(f"Vulnerability checking error: {e}")

    def _verify_exploit_safety(self, exploit: ExploitTemplate) -> bool:
        """Verify that an exploit is safe to attempt"""
        try:
            # Check if target is in scope
            if not self._is_target_in_scope(self.current_target):
                return False
            
            # Check safety requirements
            for check in exploit.safety_checks:
                if not self._run_safety_check(check):
                    return False
            
            # Check for dangerous payloads
            if self._is_payload_dangerous(exploit.payload):
                return False
            
            # Verify cleanup is possible
            if not self._verify_cleanup_possible(exploit.cleanup):
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"Exploit safety verification failed: {e}")
            return False

    def _attempt_exploit(self, exploit: ExploitTemplate, 
                        vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt to exploit a vulnerability"""
        result = {
            'timestamp': datetime.now().isoformat(),
            'exploit': exploit.name,
            'vulnerability': vulnerability,
            'success': False
        }
        
        try:
            # Prepare exploitation
            self.logger.info(f"Attempting exploit: {exploit.name}")
            
            # Check requirements
            if not self._check_exploit_requirements(exploit):
                result['error'] = "Requirements not met"
                return result
            
            # Backup state if needed
            backup = self._backup_target_state()
            
            # Execute exploit
            execution = self._execute_exploit_payload(exploit.payload)
            result.update(execution)
            
            # Verify success
            if self._verify_exploitation_success(exploit.success_indicators):
                result['success'] = True
                
            # Cleanup if needed
            if not result['success'] or self.test_options.get('cleanup', True):
                self._cleanup_exploitation(exploit.cleanup)
                
        except Exception as e:
            self.logger.error(f"Exploitation attempt failed: {e}")
            result['error'] = str(e)
            
        return result

    def _check_persistence(self, exploit_result: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Check for persistence mechanisms from successful exploits"""
        try:
            persistence_indicators = {
                'files': self._check_file_persistence(),
                'registry': self._check_registry_persistence(),
                'processes': self._check_process_persistence(),
                'services': self._check_service_persistence(),
                'network': self._check_network_persistence()
            }
            
            # Filter out empty results
            persistence = {k: v for k, v in persistence_indicators.items() if v}
            
            if persistence:
                return {
                    'type': 'multiple' if len(persistence) > 1 else list(persistence.keys())[0],
                    'indicators': persistence,
                    'timestamp': datetime.now().isoformat()
                }
            
            return None
            
        except Exception as e:
            self.logger.error(f"Persistence checking failed: {e}")
            return None

    def generate_pentest_report(self, test_id: str) -> PenetrationTest:
        """Generate comprehensive pentest report"""
        try:
            # Calculate risk level
            risk_level = self._calculate_risk_level()
            
            # Generate recommendations
            recommendations = self._generate_security_recommendations()
            
            # Create report
            report = PenetrationTest(
                test_id=test_id,
                timestamp=datetime.now().isoformat(),
                target=self.current_target,
                successful_exploits=self.successful_exploits,
                failed_exploits=self.failed_exploits,
                vulnerabilities=self.discovered_vulns,
                evidence=self._collect_evidence(),
                notes=self._generate_test_notes(),
                risk_level=risk_level,
                recommendations=recommendations
            )
            
            # Save report
            self._save_pentest_report(report)
            
            return report
            
        except Exception as e:
            self.logger.error(f"Failed to generate pentest report: {e}")
            raise

    def _calculate_risk_level(self) -> str:
        """Calculate overall risk level"""
        try:
            # Count critical vulnerabilities
            critical_vulns = sum(1 for v in self.discovered_vulns 
                               if v.get('severity') == 'critical')
            
            # Count successful exploits
            successful_count = len(self.successful_exploits)
            
            # Determine risk level
            if critical_vulns > 0 or successful_count > 2:
                return "critical"
            elif successful_count > 0 or critical_vulns > 0:
                return "high"
            elif self.discovered_vulns:
                return "medium"
            else:
                return "low"
                
        except Exception as e:
            self.logger.error(f"Risk calculation failed: {e}")
            return "unknown"

    def _generate_security_recommendations(self) -> List[str]:
        """Generate security improvement recommendations"""
        recommendations = set()
        
        try:
            # Add vulnerability-specific recommendations
            for vuln in self.discovered_vulns:
                if 'recommendation' in vuln:
                    recommendations.add(vuln['recommendation'])
            
            # Add exploit-specific recommendations
            for exploit in self.successful_exploits:
                if 'mitigation' in exploit:
                    recommendations.add(exploit['mitigation'])
            
            # Add general security recommendations
            recommendations.update([
                "Implement network segmentation",
                "Regular security patching",
                "Security awareness training",
                "Implement access controls",
                "Enable comprehensive logging"
            ])
            
        except Exception as e:
            self.logger.error(f"Failed to generate recommendations: {e}")
            recommendations.add("Error generating some recommendations")
            
        return list(recommendations)

    def _collect_evidence(self) -> List[Dict[str, Any]]:
        """Collect all evidence from the penetration test"""
        evidence = []
        
        try:
            # Add vulnerability evidence
            for vuln in self.discovered_vulns:
                evidence.append({
                    'type': 'vulnerability',
                    'timestamp': vuln['timestamp'],
                    'details': {
                        'name': vuln.get('name', 'Unknown'),
                        'severity': vuln.get('severity', 'unknown'),
                        'service': vuln.get('service', {}),
                        'proof': vuln.get('proof', 'No proof available')
                    }
                })
            
            # Add exploitation evidence
            for exploit in self.successful_exploits:
                evidence.append({
                    'type': 'exploitation',
                    'timestamp': exploit['timestamp'],
                    'details': {
                        'exploit': exploit['exploit'],
                        'vulnerability': exploit['vulnerability'],
                        'proof': exploit.get('proof', 'No proof available')
                    }
                })
            
        except Exception as e:
            self.logger.error(f"Failed to collect evidence: {e}")
            
        return evidence

    def _generate_test_notes(self) -> List[str]:
        """Generate detailed test notes"""
        notes = []
        
        try:
            # Add test summary
            notes.append(f"Penetration test of {self.current_target}")
            notes.append(f"Discovered {len(self.discovered_vulns)} vulnerabilities")
            notes.append(f"Successfully exploited {len(self.successful_exploits)} vulnerabilities")
            
            # Add vulnerability notes
            for vuln in self.discovered_vulns:
                notes.append(
                    f"[VULN] {vuln.get('name', 'Unknown vulnerability')} - "
                    f"Severity: {vuln.get('severity', 'unknown')}"
                )
            
            # Add exploitation notes
            for exploit in self.successful_exploits:
                notes.append(
                    f"[EXPLOIT] {exploit['exploit']} - "
                    f"Target: {exploit['vulnerability'].get('name', 'Unknown')}"
                )
                
            if exploit.get('persistence'):
                notes.append(
                    f"[PERSISTENCE] Found {exploit['persistence']['type']} "
                    f"persistence mechanism"
                )
            
        except Exception as e:
            self.logger.error(f"Failed to generate test notes: {e}")
            notes.append("[ERROR] Failed to generate complete test notes")
            
        return notes

    def _save_pentest_report(self, report: PenetrationTest) -> None:
        """Save pentest report to disk"""
        try:
            # Create reports directory
            reports_dir = Path("reports/pentests")
            reports_dir.mkdir(exist_ok=True, parents=True)
            
            # Convert report to dict
            report_dict = {
                'test_id': report.test_id,
                'timestamp': report.timestamp,
                'target': report.target,
                'successful_exploits': report.successful_exploits,
                'failed_exploits': report.failed_exploits,
                'vulnerabilities': report.vulnerabilities,
                'evidence': report.evidence,
                'notes': report.notes,
                'risk_level': report.risk_level,
                'recommendations': report.recommendations
            }
            
            # Save as JSON
            report_file = reports_dir / f"pentest_report_{report.test_id}.json"
            with open(report_file, 'w') as f:
                json.dump(report_dict, f, indent=2)
                
            self.logger.info(f"✅ Pentest report saved: {report_file}")
            
        except Exception as e:
            self.logger.error(f"Failed to save pentest report: {e}")

    def stop_pentest(self) -> None:
        """Stop all pentesting threads"""
        try:
            self.stop_event.set()
            self.thread_pool.shutdown(wait=True)
            self.active_test = False
            self.logger.info("✅ Penetration test stopped")
            
        except Exception as e:
            self.logger.error(f"Error stopping pentest: {e}")
